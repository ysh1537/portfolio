import{r as t,u as ge,an as Pe,a as se,_ as be,D as we,V as I,ab as Se,ao as ie,t as oe,R as Ee,M as We}from"./index-DIejhpZU.js";const T=new I,Z=new I,Re=new I,re=new Se;function je(e,n,r){const i=T.setFromMatrixPosition(e.matrixWorld);i.project(n);const o=r.width/2,a=r.height/2;return[i.x*o+o,-(i.y*a)+a]}function $e(e,n){const r=T.setFromMatrixPosition(e.matrixWorld),i=Z.setFromMatrixPosition(n.matrixWorld),o=r.sub(i),a=n.getWorldDirection(Re);return o.angleTo(a)>Math.PI/2}function Ce(e,n,r,i){const o=T.setFromMatrixPosition(e.matrixWorld),a=o.clone();a.project(n),re.set(a.x,a.y),r.setFromCamera(re,n);const x=r.intersectObjects(i,!0);if(x.length){const M=x[0].distance;return o.distanceTo(r.ray.origin)<M}return!0}function Oe(e,n){if(n instanceof oe)return n.zoom;if(n instanceof ie){const r=T.setFromMatrixPosition(e.matrixWorld),i=Z.setFromMatrixPosition(n.matrixWorld),o=n.fov*Math.PI/180,a=r.distanceTo(i);return 1/(2*Math.tan(o/2)*a)}else return 1}function Fe(e,n,r){if(n instanceof ie||n instanceof oe){const i=T.setFromMatrixPosition(e.matrixWorld),o=Z.setFromMatrixPosition(n.matrixWorld),a=i.distanceTo(o),x=(r[1]-r[0])/(n.far-n.near),M=r[1]-x*n.far;return Math.round(x*a+M)}}const B=e=>Math.abs(e)<1e-10?0:e;function ae(e,n,r=""){let i="matrix3d(";for(let o=0;o!==16;o++)i+=B(n[o]*e.elements[o])+(o!==15?",":")");return r+i}const Te=(e=>n=>ae(n,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),He=(e=>(n,r)=>ae(n,e(r),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Ve(e){return e&&typeof e=="object"&&"current"in e}const De=t.forwardRef(({children:e,eps:n=.001,style:r,className:i,prepend:o,center:a,fullscreen:x,portal:M,distanceFactor:P,sprite:v=!1,transform:f=!1,occlude:c,onOcclude:E,castShadow:$,receiveShadow:W,material:C,geometry:U,zIndexRange:H=[16777271,0],calculatePosition:G=je,as:ce="div",wrapperClass:k,pointerEvents:q="auto",...p},J)=>{const{gl:K,camera:l,scene:Q,size:d,raycaster:le,events:ue,viewport:fe}=ge(),[u]=t.useState(()=>document.createElement(ce)),L=t.useRef(),m=t.useRef(null),X=t.useRef(0),V=t.useRef([0,0]),O=t.useRef(null),N=t.useRef(null),R=M?.current||ue.connected||K.domElement.parentNode,g=t.useRef(null),z=t.useRef(!1),A=t.useMemo(()=>c&&c!=="blending"||Array.isArray(c)&&c.length&&Ve(c[0]),[c]);t.useLayoutEffect(()=>{const h=K.domElement;c&&c==="blending"?(h.style.zIndex=`${Math.floor(H[0]/2)}`,h.style.position="absolute",h.style.pointerEvents="none"):(h.style.zIndex=null,h.style.position=null,h.style.pointerEvents=null)},[c]),t.useLayoutEffect(()=>{if(m.current){const h=L.current=Pe.createRoot(u);if(Q.updateMatrixWorld(),f)u.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const s=G(m.current,l,d);u.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${s[0]}px,${s[1]}px,0);transform-origin:0 0;`}return R&&(o?R.prepend(u):R.appendChild(u)),()=>{R&&R.removeChild(u),h.unmount()}}},[R,f]),t.useLayoutEffect(()=>{k&&(u.className=k)},[k]);const Y=t.useMemo(()=>f?{position:"absolute",top:0,left:0,width:d.width,height:d.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:a?"translate3d(-50%,-50%,0)":"none",...x&&{top:-d.height/2,left:-d.width/2,width:d.width,height:d.height},...r},[r,a,x,d,f]),de=t.useMemo(()=>({position:"absolute",pointerEvents:q}),[q]);t.useLayoutEffect(()=>{if(z.current=!1,f){var h;(h=L.current)==null||h.render(t.createElement("div",{ref:O,style:Y},t.createElement("div",{ref:N,style:de},t.createElement("div",{ref:J,className:i,style:r,children:e}))))}else{var s;(s=L.current)==null||s.render(t.createElement("div",{ref:J,style:Y,className:i,children:e}))}});const j=t.useRef(!0);se(h=>{if(m.current){l.updateMatrixWorld(),m.current.updateWorldMatrix(!0,!1);const s=f?V.current:G(m.current,l,d);if(f||Math.abs(X.current-l.zoom)>n||Math.abs(V.current[0]-s[0])>n||Math.abs(V.current[1]-s[1])>n){const b=$e(m.current,l);let y=!1;A&&(Array.isArray(c)?y=c.map(w=>w.current):c!=="blending"&&(y=[Q]));const F=j.current;if(y){const w=Ce(m.current,l,le,y);j.current=w&&!b}else j.current=!b;F!==j.current&&(E?E(!j.current):u.style.display=j.current?"block":"none");const D=Math.floor(H[0]/2),he=c?A?[H[0],D]:[D-1,0]:H;if(u.style.zIndex=`${Fe(m.current,l,he)}`,f){const[w,te]=[d.width/2,d.height/2],_=l.projectionMatrix.elements[5]*te,{isOrthographicCamera:ne,top:me,left:xe,bottom:ve,right:pe}=l,ye=Te(l.matrixWorldInverse),Me=ne?`scale(${_})translate(${B(-(pe+xe)/2)}px,${B((me+ve)/2)}px)`:`translateZ(${_}px)`;let S=m.current.matrixWorld;v&&(S=l.matrixWorldInverse.clone().transpose().copyPosition(S).scale(m.current.scale),S.elements[3]=S.elements[7]=S.elements[11]=0,S.elements[15]=1),u.style.width=d.width+"px",u.style.height=d.height+"px",u.style.perspective=ne?"":`${_}px`,O.current&&N.current&&(O.current.style.transform=`${Me}${ye}translate(${w}px,${te}px)`,N.current.style.transform=He(S,1/((P||10)/400)))}else{const w=P===void 0?1:Oe(m.current,l)*P;u.style.transform=`translate3d(${s[0]}px,${s[1]}px,0) scale(${w})`}V.current=s,X.current=l.zoom}}if(!A&&g.current&&!z.current)if(f){if(O.current){const s=O.current.children[0];if(s!=null&&s.clientWidth&&s!=null&&s.clientHeight){const{isOrthographicCamera:b}=l;if(b||U)p.scale&&(Array.isArray(p.scale)?p.scale instanceof I?g.current.scale.copy(p.scale.clone().divideScalar(1)):g.current.scale.set(1/p.scale[0],1/p.scale[1],1/p.scale[2]):g.current.scale.setScalar(1/p.scale));else{const y=(P||10)/400,F=s.clientWidth*y,D=s.clientHeight*y;g.current.scale.set(F,D,1)}z.current=!0}}}else{const s=u.children[0];if(s!=null&&s.clientWidth&&s!=null&&s.clientHeight){const b=1/fe.factor,y=s.clientWidth*b,F=s.clientHeight*b;g.current.scale.set(y,F,1),z.current=!0}g.current.lookAt(h.camera.position)}});const ee=t.useMemo(()=>({vertexShader:f?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[f]);return t.createElement("group",be({},p,{ref:m}),c&&!A&&t.createElement("mesh",{castShadow:$,receiveShadow:W,ref:g},U||t.createElement("planeGeometry",null),C||t.createElement("shaderMaterial",{side:we,vertexShader:ee.vertexShader,fragmentShader:ee.fragmentShader})))}),ze=()=>parseInt(Ee.replace(/\D+/g,"")),Ie=ze(),ke=t.forwardRef(({children:e,enabled:n=!0,speed:r=1,rotationIntensity:i=1,floatIntensity:o=1,floatingRange:a=[-.1,.1],autoInvalidate:x=!1,...M},P)=>{const v=t.useRef(null);t.useImperativeHandle(P,()=>v.current,[]);const f=t.useRef(Math.random()*1e4);return se(c=>{var E,$;if(!n||r===0)return;x&&c.invalidate();const W=f.current+c.clock.getElapsedTime();v.current.rotation.x=Math.cos(W/4*r)/8*i,v.current.rotation.y=Math.sin(W/4*r)/8*i,v.current.rotation.z=Math.sin(W/4*r)/20*i;let C=Math.sin(W/4*r)/10;C=We.mapLinear(C,-.1,.1,(E=a?.[0])!==null&&E!==void 0?E:-.1,($=a?.[1])!==null&&$!==void 0?$:.1),v.current.position.y=C*o,v.current.updateMatrix()}),t.createElement("group",M,t.createElement("group",{ref:v,matrixAutoUpdate:!1},e))});export{ke as F,De as H,Ie as v};
